#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrartcl
\begin_preamble
\input{./texconfig.tex}
\end_preamble
\use_default_options true
\master main.lyx
\begin_modules
theorems-ams
theorems-sec
theorems-ams-extended
eqs-within-sections
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format pdf2
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation landscape
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 1
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 30cm
\paperheight 20cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part
LeetCode 
\end_layout

\begin_layout Addsec
LeetCode 27.
 Remove Element
\end_layout

\begin_layout Paragraph
Two Pointer
\end_layout

\begin_layout Standard
Regular two pointer approach.
 The implementation is routine.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{9043}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 53.
 Maximum Subarray
\end_layout

\begin_layout Paragraph
Dynamic Programming 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the maximum subarray sum ending with 
\begin_inset Formula $\var{nums[i]},$
\end_inset

, then we have 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
\var{nums[0]} & \text{if }i=0\\
\max(f(i-1)+\var{nums[i]},\var{nums[i]}) & \mathrm{otherwise}
\end{cases}.
\end{equation}

\end_inset

Then the final answer is 
\begin_inset Formula $\max_{i=0}^{n-1}f(i),$
\end_inset

 where 
\begin_inset Formula $n={\tt {std::size}(\var{nums}).}$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18141}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 55.
 Jump Game 
\begin_inset CommandInset label
LatexCommand label
name "sec:55-1"

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming 1 
\begin_inset CommandInset label
LatexCommand label
name "par:55-dp1-1"

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the reachability of index 
\begin_inset Formula $i$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
\mathrm{true} & \text{if }i=0\\
\mathrm{true} & \text{if there exists }k\in[1,i-1]\text{ such that }f(k)=\mathrm{true}\text{ and }\texttt{nums}[k]+k\geq i\\
\mathrm{false} & \mathrm{otherwise}.
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $f(i).$
\end_inset

 The overall runtime complexity is 
\begin_inset Formula $O(n^{2})$
\end_inset

 and memory complexity is 
\begin_inset Formula $O(n)$
\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18138}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming 2 
\begin_inset CommandInset label
LatexCommand label
name "par:55-dp2-1"

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the maximum distance that can be achieved from index 
\begin_inset Formula $i$
\end_inset

.
 Then we have 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
\texttt{nums}[0] & \text{if }i=0\\
\max(f(i-1),\texttt{nums}[i]+i) & \text{else if }f(i-1)\geq i\\
f(i-1) & \text{otherwise }
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $\max_{i=0}^{n-1}f(i)\geq n-1.$
\end_inset

 The runtime complexity is 
\begin_inset Formula $O(n)$
\end_inset

 and memory complexity is 
\begin_inset Formula $O(n)$
\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18138}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 66.
 Plus One
\end_layout

\begin_layout Paragraph
Simulation (Recursive) 
\end_layout

\begin_layout Standard
We use a stateful recursive lambda, 
\begin_inset Formula $f_{[\text{\var{carry},\var D}]}(i)$
\end_inset

, to recursively simulate the addition process, where 
\begin_inset Formula $f(i)$
\end_inset

 denote the process at index 
\begin_inset Formula $i$
\end_inset

, 
\begin_inset Formula $\var{carry}$
\end_inset

 represents if a carry of one will be added in the current digit, and 
\begin_inset Formula $\var D$
\end_inset

 is a mutable copy of 
\begin_inset Formula $\var{digits}$
\end_inset

.
 We start from 
\begin_inset Formula $i=n-1$
\end_inset

, where 
\begin_inset Formula $n={\tt {std::size(\var{digits})}.}$
\end_inset

 The implementation of 
\begin_inset Formula $f$
\end_inset

 is routine.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18142}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 88.
 Merge Sorted Array 
\end_layout

\begin_layout Paragraph
Simulation (Recursive)
\end_layout

\begin_layout Standard
We implement a function 
\begin_inset Formula $f(i,n_{1},n_{2})$
\end_inset

 to recursively fill 
\begin_inset Formula $\var{nums1}$
\end_inset

 backward putting 
\begin_inset Formula $\var{nums1[i]}=\max(\var{nums1}[n_{1}],\var{nums2}[n_{2}]).$
\end_inset

 The implementation is routine.
 The resulting runtime complexity is 
\begin_inset Formula $O(n+m)$
\end_inset

 and memory complexity is 
\begin_inset Formula $O(1)$
\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18143}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 233.
 Number of Digit One
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpdigit}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 265.
 Paint House II
\end_layout

\begin_layout Paragraph
Dynamic Programming 1 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the minimum cost to paint all houses per the specification.
 Then we have 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
\var{costs}[0][j] & \mathrm{if\ }i=0\\
\min_{k\in[0,k-1]\mathrm{\ and\ }k\neq j}\{\var{costs}[i][j]+f(i-1,k)\} & \mathrm{o.w.}
\end{cases}.
\end{equation}

\end_inset

The time complexity if 
\begin_inset Formula $O(nk^{2}).$
\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming 2
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the minimum cost to paint all houses per the specification.
 And 
\begin_inset Formula $g(i)=\{{\tt {kth}(0,f([i][0,...,k-1]),{\tt {kth}(1,f([i][0,...,k-1])\}}}$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
\var{costs}[0][j] & \mathrm{if\ }i=0,\\
f(i,g(i-1)[1].{\tt {index})+\var{costs}[i][j]} & \mathrm{else\ if}\ g(i-1)[0].{\tt {index}=j}\\
f(i,g(i-1)[0].{\tt {index})+\var{costs}[i][j]} & \mathrm{o.w.}
\end{cases}.
\end{equation}

\end_inset

The time complexity is 
\begin_inset Formula $O(nk).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 276.
 Paint Fence
\end_layout

\begin_layout Paragraph
Dynamic Programming 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the total numbers of way to paint fences 
\begin_inset Formula $[0,...,i]$
\end_inset

.
 Then we have 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
k & \mathrm{if\ }i=0\\
k^{2} & \mathrm{else\ if\ }i=1\\
f(i-1)\times(k-1)+f(i-2)\times(k-1) & \mathrm{o.w.}
\end{cases},
\end{equation}

\end_inset

where the two parts in the last transition function is to tackle with the
 two cases where the 
\begin_inset Formula $i$
\end_inset

th block has the same color as the 
\begin_inset Formula $(i-1)$
\end_inset

th, in which case it must be difference from the 
\begin_inset Formula $(i-2)$
\end_inset

th fence, and different color as the 
\begin_inset Formula $(i-1)$
\end_inset

th fence.
 
\end_layout

\begin_layout Addsec
LeetCode 300.
 Longest Increasing Subsequence 
\begin_inset CommandInset label
LatexCommand label
name "sec:lc300-longest-increasing-subsequence"

\end_inset


\end_layout

\begin_layout Paragraph
Patience Sorting
\end_layout

\begin_layout Standard
There is a connection between the game of patience and and problem of LIS.
 The minimum number of piles formed in the game of patience is equal to
 the length of LIS.
 For more details, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:algo-patient-sorting"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The time complexity is 
\begin_inset Formula $O(n\log n)$
\end_inset

.
 
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the length of the LIS ending at 
\begin_inset Formula $\var{nums}[i]$
\end_inset

.
 Then it follows that
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
\max_{0\leq k\leq i-1\ \text{and\ }\var{nums}[k]<\var{nums}[i]}\{1+f(k)\} & \text{if }i>0\\
1 & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset

Then the final answer is 
\begin_inset Formula $\max_{0\leq i\leq n-1}f(i).$
\end_inset

 The overall run time complexity is 
\begin_inset Formula $O(n^{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 312.
 Burst Balloons
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the maximum coins after bursting 
\begin_inset Formula $\var{nums}[i:j].$
\end_inset

 Then we have that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
\max_{i\leq k\leq k}\{\var{nums}[k]\cdot\var{nums}[i-1]\cdot\var{nums}[j+1]+f(i,k-1)+f(k+1,j)\} & \mathrm{if\ }i<j\\
\var{nums}[i]\cdot\var{nums}[i-1]\cdot\var{nums}[i+1] & \mathrm{else\ if\ }i=j\\
0 & \mathrm{else\ if\ }i>j
\end{cases}.
\end{equation}

\end_inset

The final answer is then 
\begin_inset Formula $f(0,n-1),$
\end_inset

 where 
\begin_inset Formula $n=\fn{std::size}(\var{nums}).$
\end_inset

 Note that 
\begin_inset Formula $\var{nums}[-1]$
\end_inset

 and 
\begin_inset Formula $\var{nums}[n]$
\end_inset

 is needs to be dealt with in the implementation if we don't pad 
\begin_inset Formula $\var{nums}$
\end_inset

.
 The overall running time is 
\begin_inset Formula $O(n^{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 321.
 Create Maximum Number
\end_layout

\begin_layout Paragraph
Dynamic Programming with Greedy and Monotone Stack
\end_layout

\begin_layout Standard
We can decompose this problem into three parts.
 The final solution of the problem is 
\begin_inset Formula 
\begin{equation}
\min_{(i,j)\in[0,...,n_{1}]\times[0,...,n_{2}]\text{ and }i+j=k}\fn{merge}(g(\var{nums1},i),g(\var{nums2},j)).
\end{equation}

\end_inset

There 
\begin_inset Formula $g(A,k)$
\end_inset

 returns the largest 
\begin_inset Formula $k$
\end_inset

 element subsequence in 
\begin_inset Formula $A$
\end_inset

.
 And 
\begin_inset Formula $\fn{merge}(A_{1},A_{2})$
\end_inset

 returns the largest sequentially merged array from 
\begin_inset Formula $A_{1}$
\end_inset

 and 
\begin_inset Formula $A_{2}$
\end_inset

 in term of lexicographical ordering.
 Note that 
\begin_inset Formula $g(A,k)$
\end_inset

 can be computed efficiently using a monotone stack, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:monotone-stack-kth-elemnt-subseq"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 And 
\begin_inset Formula $\fn{merge}$
\end_inset

 can be implemented using a greedy idea: we with 
\begin_inset Formula $i=0$
\end_inset

 and 
\begin_inset Formula $j=0$
\end_inset

 and an accumulator 
\begin_inset Formula $\var{acc}$
\end_inset

 of result.
 If 
\begin_inset Formula $A_{1}[i:-1]\geq A_{2}[j:-1],$
\end_inset

 we accumulate 
\begin_inset Formula $A_{1}[i]$
\end_inset

 into 
\begin_inset Formula $\var{acc}$
\end_inset

 and increment 
\begin_inset Formula $i$
\end_inset

, otherwise we merge 
\begin_inset Formula $A_{2}[j]$
\end_inset

 into 
\begin_inset Formula $\var{acc}$
\end_inset

 and increment 
\begin_inset Formula $j$
\end_inset

.
 The correctness of this merging algorithm can be proved using an exchange
 argument.
 The overall time complexity of this is 
\begin_inset Formula $O(\max(n_{1},n_{2})^{2}k).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 322.
 Coin Change
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpknapsack}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(S)$
\end_inset

 denote the minimum number of coins needed to reach value 
\begin_inset Formula $S.$
\end_inset

 Then we have f
\begin_inset Formula 
\begin{equation}
f(S)=\begin{cases}
\min_{c\in\var{coins}\ \text{and }S-c\geq0}\{1+f(S-c)\} & \text{if }S>0\\
0 & \mathrm{else\ if}\ S=0
\end{cases},
\end{equation}

\end_inset

where we let 
\begin_inset Formula $\min(\emptyset):=+\infty$
\end_inset

 to handle the infeasible cases.
 The time complexity is 
\begin_inset Formula $O(nS),$
\end_inset

 where 
\begin_inset Formula $n=\fn{std::size}(\var{coins}).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 338.
 Counting Bits
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 be the number of 1's in 
\begin_inset Formula $i$
\end_inset

's binary representation.
 Then we have that 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
0 & \If i=0\\
1 & \mathrm{else\ if\ }i=1\\
f(i/2) & \mathrm{else\ if\ }i\mathrm{\ is\ even}\\
f(i-1)+1 & \mathrm{else\ if\ }i\ \text{is odd}
\end{cases}.
\end{equation}

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 343.
 Integer Break
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the maximum product for number 
\begin_inset Formula $i$
\end_inset

.
 Then we have 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
1 & \If i=1\\
\max_{1\leq k\leq i-1}(k\cdot f(i-k),k\cdot(i-k)) & \ow
\end{cases}.
\end{equation}

\end_inset

The final answer if then 
\begin_inset Formula $f(n).$
\end_inset

 The overall runtime complexity is 
\begin_inset Formula $O(n^{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 351.
 Android Unlock Patterns
\end_layout

\begin_layout Paragraph
Backtrack
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,k)$
\end_inset

 denote the number of possible patterns with length 
\begin_inset Formula $k$
\end_inset

 that starts from 
\begin_inset Formula $i$
\end_inset

.
 Then the final answer is 
\begin_inset Formula $\sum_{i=1}^{9}\sum_{k=m}^{n}f(i,k)$
\end_inset

.
 We note that 
\begin_inset Formula $f(i,k)$
\end_inset

 can be computed using exhaustive search (backtrack).
 We will also create a list 
\begin_inset Formula $\var{blocks}$
\end_inset

 to keep track of the jumping across cases for every key; for example, 
\begin_inset Formula $\var{blocks}[1][\{3,9,7\}]=\{2,5,4\}$
\end_inset

 and 
\begin_inset Formula $\var{blocks}[1][k]=\emptyset$
\end_inset

 for all other 
\begin_inset Formula $k\in[1,...,9]\backslash\{3,9,7\}.$
\end_inset

 
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Using the similar idea as before, we note that 
\begin_inset Formula $f$
\end_inset

 can actually be memoized.
 Let 
\begin_inset Formula $f(S,k,l)$
\end_inset

 denote the number of possible patterns of length 
\begin_inset Formula $l$
\end_inset

 staring from 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 354.
 Russian Doll Envelopes
\end_layout

\begin_layout Paragraph
Patience Sorting
\end_layout

\begin_layout Standard
Convert this problem into a LIS problem on the last coordinate.
 Note that LIS problem can be solved using the patience sorting algorithm
 in 
\begin_inset Formula $O(n\log n)$
\end_inset

 run time, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:algo-patient-sorting"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 357.
 Count Numbers with Unique Digits
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpdigit}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the counts of numbers with unique digits such that 
\begin_inset Formula $0\leq x\leq10^{n}.$
\end_inset

 Then we have that 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
10 & \If i=1\\
9\cdot9 & \text{else if }i=2\\
f(i-1)\cdot(10-i+1) & \text{else if }i>2
\end{cases}.
\end{equation}

\end_inset

Then the final answer is then 
\begin_inset Formula $\sum_{i=1}^{n}f(i).$
\end_inset

 We note that the special case of 
\begin_inset Formula $n=0$
\end_inset

 is to be dealt with separately as a special case.
\end_layout

\begin_layout Addsec
LeetCode 361.
 Bomb Enemy
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j,d)$
\end_inset

 denote the number of enemies that can be killed in direction 
\begin_inset Formula $d$
\end_inset

 if the bomb is dropped in 
\begin_inset Formula $\var{grid}[i][j].$
\end_inset

 Then we have 
\begin_inset Formula 
\begin{equation}
f(i,j,d)=\begin{cases}
0 & \If\var{grid}[i][j]=\var W\text{ or }\text{not }\fn{inbound}(i,j)\\
1+f(i+\var{dr}[d],j+\var{dc}[d],d) & \text{else if }\var{grid}[i][j]=\var E\\
f(i+\var{dr}[d],j+\var{dc}[d],d) & \text{else if }\var{grid}[i][j]=0
\end{cases}.
\end{equation}

\end_inset

Then the final solution is 
\begin_inset Formula $\max_{i,j\text{ and }\var{grid}[i][j]=0}\sum_{d}f(i,j,d)$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 368.
 Largest Divisible Subset
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
First we sort the 
\begin_inset Formula $\var{nums}$
\end_inset

.
 Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the maximum divisible set size ending with 
\begin_inset Formula $\var{nums}[i].$
\end_inset

 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
1 & \If i=0\\
\max_{0\leq j\leq i-1\text{ and }\var{nums}[i]\ |\ \var{nums}[j]}\{f(j)+1\} & \text{o.w}
\end{cases}.
\end{equation}

\end_inset

Then we can use backtrace to recursively build up the answer.
\end_layout

\begin_layout Addsec
LeetCode 375.
 Guess Number Higher or Lower II
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the minimum number of amount one need a guarantee a win for number
 to be picked in range 
\begin_inset Formula $[i,j].$
\end_inset

 Then we have that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
0 & \If i=j\ \text{or }j>i\\
k+\min_{i\leq k\leq j}\{f(i,k-1)+f(k+1,j)\} & \text{else if }i<j
\end{cases}.
\end{equation}

\end_inset

The final answer is then 
\begin_inset Formula $f(1,n)$
\end_inset

.
 The overall run time complexity is 
\begin_inset Formula $O(n^{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 392.
 Is Subsequence
\end_layout

\begin_layout Paragraph
Greedy with two pointer
\end_layout

\begin_layout Standard
Just match 
\begin_inset Formula $\var s$
\end_inset

 with 
\begin_inset Formula $\var t$
\end_inset

 from the beginning.
\end_layout

\begin_layout Addsec
LeetCode 376.
 Wiggle Subsequence 
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the length of the longest wiggle subsequence ending with 
\begin_inset Formula $\var{nums}[i]$
\end_inset

 and the difference between last two elements is positive and 
\begin_inset Formula $g(i)$
\end_inset

 denote the length of the longest wiggle subsequence ending with 
\begin_inset Formula $\var{nums}[i]]$
\end_inset

 and the difference between the last two elements is negative.
 Then we have 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
1 & \text{if }i=0\\
\max_{0\leq j<i,\var{nums}[i]<\var{nums}[j]}\{1+g(j)\} & \text{o.w.}
\end{cases},
\end{equation}

\end_inset

and 
\begin_inset Formula 
\begin{equation}
g(i)=\begin{cases}
1 & \text{if }i=0\\
\max_{0\leq j<i,\var{nums}[i]>\var{nums}[j]}\{1+f(j)\} & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset

Then the final answer is 
\begin_inset Formula $\max_{0\leq i\leq n-1}\{\max(f(i),g(i))\}.$
\end_inset

 And the overall running time complexity is 
\begin_inset Formula $O(n^{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 403.
 Frog Jump
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(x,y)$
\end_inset

 denote the reachability to 
\begin_inset Formula $x$
\end_inset

 with step 
\begin_inset Formula $y$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(x,y)=\begin{cases}
\var{true} & \text{if }x=1,y=1\\
f(x-y,y)\lor f(x-y,y-1)\lor f(x-y,y+1) & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset

Since there is not limit on steps, we have that 
\begin_inset Formula $\bigvee_{i=1}^{1001}f(\var{stones}[-1],i).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 410.
 Split Array Largest Sum
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the largest sum splitting array 
\begin_inset Formula $\var{nums}[0:i]$
\end_inset

 into 
\begin_inset Formula $j$
\end_inset

 parts.
 Then we have 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
\fn{RMQ}(0,i) & \If j=1\\
\min_{j-1\leq k\leq i}\{\fn{RMQ}(k,i)+f(k-1,j-1)\} & \text{o.w}.
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $f(n-1,m).$
\end_inset

 The overall runtime complexity if 
\begin_inset Formula $O(n^{2}m)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Binary Search
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(x)$
\end_inset

 denote the minimum number of contiguous subarrays that can be splitted
 with sum less than or equal to 
\begin_inset Formula $x$
\end_inset

.
 Then we note that 
\begin_inset Formula $f$
\end_inset

 is a decreasing function.
 The desired answer is then 
\begin_inset Formula $\sup\{x:f(x)\leq m\}.$
\end_inset

 This can be queried using binary search on 
\begin_inset Formula $f$
\end_inset

 on range 
\begin_inset Formula $[\max_{i}\{\var{nums}[i]\},\sum_{i}\var{nums}[i]]$
\end_inset

.
 The runtime complexity is 
\begin_inset Formula $O(n\log n)$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 413.
 Arithmetic Slices
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the number arithmetic slices ending with 
\begin_inset Formula $\var A[i].$
\end_inset

 Then we have 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
0 & \If i<2\\
1+f(i-1) & \text{else if }A[i]-A[i-1]=A[i-1]-A[i-2]\\
0 & \text{else if }A[i]-A[i-1]\neq A[i-1]-A[i-2]
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $\sum_{i=0}^{n-1}f(i)$
\end_inset

, where 
\begin_inset Formula $n=\fn{std::size}(\var A).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 418.
 Sentence Screen Fitting
\end_layout

\begin_layout Paragraph
Memoization
\end_layout

\begin_layout Standard
We design a function 
\begin_inset Formula $\fn{fill}(i)$
\end_inset

 which fills a row starting from 
\begin_inset Formula $\var{sentence}[i]$
\end_inset

 and stop until this row cannot be filled.
 It returns the number of words filled and the word next to the last filled
 word.
 Note that the sentences can be filled multiple times in one row if the
 column size is sufficiently large.
 Then we fill the matrix row by row and accumulate the total number of words
 filled, which we denote as 
\begin_inset Formula $\var{acc\_cnt}$
\end_inset

.
 The final result is then 
\begin_inset Formula $\var{acc\_cnt}/n$
\end_inset

, where 
\begin_inset Formula $n=\size(\var{sentence})$
\end_inset

.
 To speed things up, we note that 
\begin_inset Formula $\fn{fill}$
\end_inset

 is a pure function which does not depend on other states.
 Therefore, we can memoize it to save unnecessary computation.
\end_layout

\begin_layout Addsec
LeetCode 446.
 Arithmetic Slices II
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,d)$
\end_inset

 denote the number of arithmetic slices ending with 
\begin_inset Formula $\var A[i]$
\end_inset

 with difference 
\begin_inset Formula $d.$
\end_inset

 Then we have 
\begin_inset Formula 
\begin{equation}
f(i,d)=\begin{cases}
\sum_{0\leq j<i,\var A[i]-\var A[j]=d}f(j,d)+1 & \text{if }i>1\\
1 & \text{else if }i=1\text{ and }\var A[i]-d=\var A[i-1]\\
0 & \text{else if }i=1\text{ and }\var A[i]-d\neq\var A[i-1]
\end{cases}.
\end{equation}

\end_inset

We need to note that these sequences contains arithmetic sequences with
 length 
\begin_inset Formula $2$
\end_inset

, which doesn't satisfy the requirement given in the problem.
 Hence we need to subtract them off.
 There are two ways to subtract them:
\end_layout

\begin_layout Enumerate
Let 
\begin_inset Formula $x$
\end_inset

 denote the accumulated sum for all 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

.
 Then the final answer is 
\begin_inset Formula $x-n(n-1)/2,$
\end_inset

 where 
\begin_inset Formula $n=\size(\var A).$
\end_inset


\end_layout

\begin_layout Enumerate
Let 
\begin_inset Formula $x$
\end_inset

 denote the final answer.
 Then 
\begin_inset Formula $x=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}f(j,A[i]-A[j]).$
\end_inset

 By doing so, we are excluding out the two element sequence since we are
 starting from 
\begin_inset Formula $j$
\end_inset

 instead of 
\begin_inset Formula $i$
\end_inset

.
 By doing so we are guaranteeing the first element any arithmetic slices
 therefore guaranteeing 
\begin_inset Formula $x$
\end_inset

 counts all the arithmetic slices with at least three elements.
\end_layout

\begin_layout Standard
We also note that there some int max and int min issues to be dealt with
 separately.
 Also, to speed things up, we use a 
\begin_inset Formula $\var{value\_index\_map}$
\end_inset

 to keep track of all the indices.
\end_layout

\begin_layout Addsec
LeetCode 459.
 Repeated Substring Pattern 
\begin_inset CommandInset label
LatexCommand label
name "sec:lc459"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{kmp}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
String Prefix Function
\end_layout

\begin_layout Standard
To solve this, we note the following proposition:
\end_layout

\begin_layout Proposition
Let 
\begin_inset Formula $s$
\end_inset

 be a string.
 If 
\begin_inset Formula $s$
\end_inset

 can be constructed by concatenating multiples of its proper substrings,
 then 
\begin_inset Formula $n|(n_{s}-\pi(n_{s}-1))=0,$
\end_inset

 where 
\begin_inset Formula $\pi$
\end_inset

 is the string prefix function.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proof
Suppose 
\begin_inset Formula $s=[t]_{k},$
\end_inset

 where 
\begin_inset Formula $t$
\end_inset

 is a proper substring of 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $k\geq2$
\end_inset

.
 Without loss of generality, we assume that 
\begin_inset Formula $t$
\end_inset

 is the minimal proper substring that has the property.
 We let 
\begin_inset Formula $n_{t}=\size(t)$
\end_inset

.
 Then it follows that 
\begin_inset Formula $\pi(n_{s}-1)=(k-1)\cdot n_{t}$
\end_inset

 Then it follows that 
\begin_inset Formula $n-\pi(n_{s}-1)=n_{t}$
\end_inset

.
 which is divisible by 
\begin_inset Formula $n_{s}=kn_{t}.$
\end_inset

 On the other hand, suppose 
\begin_inset Formula $s$
\end_inset

 cannot be written in the form of 
\begin_inset Formula $[t]_{k}.$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
With this in mind, it suffices to compute the prefix function, 
\begin_inset Formula $\pi$
\end_inset

, and check.
\end_layout

\begin_layout Addsec
LeetCode 464.
 Can I Win 
\begin_inset CommandInset label
LatexCommand label
name "sec:lc464"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpmask}
\end_layout

\begin_layout Plain Layout


\backslash
addlist{dpminimax}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming with BitSet
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(S,x)$
\end_inset

 denote the possibility to guarantee a win for the first player with remaining
 available number set 
\begin_inset Formula $S$
\end_inset

 and target 
\begin_inset Formula $x$
\end_inset

.
 Then we have that 
\begin_inset Formula 
\begin{equation}
f(S,x)=\begin{cases}
\var{false} & \text{if }S=\emptyset\ \text{or }\sum_{x\in S}S<x\\
(\max(S)\geq x)\fn{\ or\ }\bigvee_{x\in S}(\fn{not}f(S\backslash\{x\}-x-i)) & \text{else}
\end{cases}.
\end{equation}

\end_inset

The final answer is then 
\begin_inset Formula $f([1,...n],\var{desiredTotal}).$
\end_inset

 We note that we don't need to memoize both 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset

 since once we know 
\begin_inset Formula $S$
\end_inset

, 
\begin_inset Formula $x$
\end_inset

 can be automatically calculated.
\end_layout

\begin_layout Addsec
LeetCode 466.
 Count The Repetitions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpdouble}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming with Doubling
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,k)$
\end_inset

 denote the number of characters of of the infinite stream of 
\begin_inset Formula $s_{i}$
\end_inset

's starting from 
\begin_inset Formula $s_{1}[i]$
\end_inset

 needed to cover 
\begin_inset Formula $2^{k}$
\end_inset

 copies of 
\begin_inset Formula $s_{2}$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i,k)=\begin{cases}
\fn{single\_match\_count}(i) & \text{if }k=0\\
f(i,k-1)+f((i+f(i,j-1))\mod\ell_{1},k-1) & \text{o.w.}
\end{cases},
\end{equation}

\end_inset

where 
\begin_inset Formula $\fn{single\_match\_count}(i)$
\end_inset

 is the base case, which could be implemented as a simple accumulation.
 Then we just need to fill using double technique.
\end_layout

\begin_layout Addsec
LeetCode 467.
 Unique Substrings in Wraparound String
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{slidingwindow}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sliding Window
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(c)$
\end_inset

 denote the length of the longest increasing contiguous subarray that ends
 with 
\begin_inset Formula $c$
\end_inset

 in 
\begin_inset Formula $p$
\end_inset

.
 Then the final answer is 
\begin_inset Formula $\sum_{c\in[\var a,...,\var z]}f(c).$
\end_inset

 We also note the following:
\end_layout

\begin_layout Itemize
The contiguous subarray condition check needs to include the check to 
\begin_inset Formula $'za'$
\end_inset

 case.
\end_layout

\begin_layout Itemize
\begin_inset Formula $f(c)$
\end_inset

 can be precomputed using a sliding window.
\end_layout

\begin_layout Standard
The overall runtime is then 
\begin_inset Formula $O(n)$
\end_inset

, where 
\begin_inset Formula $n=\size(\var p).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 471.
 Encode String with Shortest Length
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpstring}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming with KMP
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the shortest encoded string for 
\begin_inset Formula $\var s[i:j].$
\end_inset

 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
\nullstring & \text{if }j-i+1\leq4\\
\tostring((j-i+1)/p)\oplus\str [\oplus f(i,i+p-1)\oplus\str ] & \text{else if }p:=\fn{compress}(\var s[i:j])>0\\
\min_{i\leq k<j}\{f(i,k)\oplus f(k+1,j)\} & \text{else if }\fn{compress}(\var s[i:j])=-1
\end{cases}.
\end{equation}

\end_inset

Note that the function 
\begin_inset Formula $\fn{compress}(i,j)$
\end_inset

 returns the number of multiples of substrings that are used to encode 
\begin_inset Formula $\var s[i:j]$
\end_inset

.
 This can be solved efficiently using KMP algorithm like in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:lc459"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We will also use a more generalized form of the prefix function 
\begin_inset Formula $\pi_{1}$
\end_inset

, where 
\begin_inset Formula $\pi_{1}(i,j)$
\end_inset

 denote equals 
\begin_inset Formula $\pi_{0}(j)$
\end_inset

 for 
\begin_inset Formula $\var s[i:j],$
\end_inset

 where 
\begin_inset Formula $\pi_{0}$
\end_inset

 is the original vanilla prefix function.
\end_layout

\begin_layout Addsec
LeetCode 472.
 Concatenated Words
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{trie}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Fold over Trie
\end_layout

\begin_layout Standard
We first build a Trie for 
\begin_inset Formula $\var{words}$
\end_inset

.
 Then we implement a fold operation to check if a given word is a concatenated
 word.
 Let 
\begin_inset Formula $f_{s}(n,i,k)$
\end_inset

 denote the fold function representing if a given word 
\begin_inset Formula $s$
\end_inset

 is a concatenated word when we start checking from trie node 
\begin_inset Formula $n$
\end_inset

 and index 
\begin_inset Formula $i$
\end_inset

 of 
\begin_inset Formula $s$
\end_inset

.
 Then we have 
\begin_inset Formula 
\begin{equation}
f_{s}(n,i,k)=\begin{cases}
n.\fn{is\_word}\ \fn{and}\ \var{cnt}\geq1 & \text{if }i=\size(s)\\
\var{false} & \text{else if }s[i]\notin n.\var{next}\\
f_{s}(n.\var{next}[s[i]],i+1,k)\text{ or }f(n,i+1,k+1) & \text{else if }s[i]\in n.\var{next}\text{ and }n.\var{next}[s[i]].\fn{is\_word}=\var{true}\\
f_{s}(n.\var{next}[s[i]],i+1,k) & \text{else if }s[i]\in n.\var{next}\text{ and }n.\var{next}[s[i]].\fn{is\_word}=\var{false}
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $\{s:s\in\var{words}\text{ and }f_{s}(\var{root},0,0)\}$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 474.
 Ones and Zeros
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpknapsack}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,r_{0},r_{1})$
\end_inset

 denote the maximum number of strings can be made with 
\begin_inset Formula $r_{0}$
\end_inset

 0's and 
\begin_inset Formula $r_{1}$
\end_inset

 1's for 
\begin_inset Formula $\var{strs}[0:i].$
\end_inset

 Then we have that 
\begin_inset Formula 
\begin{equation}
f(i,r_{0},r_{1})=\begin{cases}
1 & \text{if }i=0\text{ and }\var{costs}[i]\leq(r_{0},r_{1})\\
0 & \text{else if }i=0\text{ and }\var{costs}[i]>(r_{0},r_{1})\\
\max(f(i-1,r_{0}-\var{costs}[i][0],r_{1}-\var{costs}[i][1]),f(i-1,r_{0},r_{1}) & \text{else if }i>0\text{ and }\var{costs}[i]\leq(r_{0},r_{1})\\
f(i-1,r_{0},r_{1}) & \text{else if }i>0\text{ and }\var{costs}[i]>(r_{0},r_{1})
\end{cases}.
\end{equation}

\end_inset

Then the final solution is 
\begin_inset Formula $f(\ell-1,m,n),$
\end_inset

 where 
\begin_inset Formula $\ell=\size(\var{strs})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 486.
 Predict the Winner
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpminimax}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 be the difference of score between player1 and player2 if they are to pick
 numbers between 
\begin_inset Formula $[i,...,j]$
\end_inset

 with player 1 pick first.
 Note that since both players are playing optimally, 
\begin_inset Formula $f(i,j)$
\end_inset

 also represents the difference player2 and player1 if they are to pick
 numbers between 
\begin_inset Formula $[i,...,j]$
\end_inset

 with player 2 pick first.
 Then we have that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
\var{nums}[i] & \text{if }i=j\\
\max(\var{nums}[i],\var{nums}[j])-\min(\var{nums}[i],\var{nums}[j]) & \text{else if }i+1=j\\
\max(\var{nums}[i]-f(i+1,j),\var{nums}[j]-f(i,j-1)) & \text{o.w. }
\end{cases}.
\end{equation}

\end_inset

The final answer is then 
\begin_inset Formula $f(0,n-1)\geq0,$
\end_inset

 where 
\begin_inset Formula $n=\size(\var{nums}).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 514.
 Freedom Trail
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpinterval}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the minimum number to open the door given that is key is 
\begin_inset Formula $\var{key}[j:-1]$
\end_inset

 and the starting position of the ring is 
\begin_inset Formula $i$
\end_inset

.
 Then we have that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
0 & \text{if }\var{ring}[i]=\var{key}[j]\text{ and }j=n_{\var{key}}-1\\
f(i,j+1) & \text{else if }\var{ring}[i]=\var{key}[j]\text{ and }j<n_{\var{key}}-1\\
\min(\var{first\_ll}(i,\var{key}[j].\var{steps},\var{first\_rr}(i,\var{key}[j]).\var{steps}) & \text{else if }\var{ring}[i]\neq\var{key}[j]\text{ and }j=n_{\var{key}}-1\\
\min(G_{\var{ll}},G_{\var{rr}}) & \text{else if }\var{ring}[i]\neq\var{key}[j]\text{ and }j<n_{\var{key}}-1
\end{cases},
\end{equation}

\end_inset

where 
\begin_inset Formula 
\begin{align}
G_{\var{ll}}(i,j) & =\var{first\_ll}(i,\var{key}[j]).\var{steps}+f(\var{first\_ll}(i,\var{key}[j]).\var{id},\var{key}[j+1]),\\
G_{\var{rr}}(i,j) & =\var{first\_rr}(i,\var{key}[j]).\var{steps}+f(\var{first\_rr}(i,\var{key}[j]).\var{id},\var{key}[j+1]).
\end{align}

\end_inset

We note that 
\begin_inset Formula $\var{first\_ll}(i,c)$
\end_inset

 and 
\begin_inset Formula $\var{first\_rr}(i,c)$
\end_inset

 returns the first match on left (right) of the ring for character 
\begin_inset Formula $c$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 516.
 Longest Palindromic Subsequence
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpinterval}
\end_layout

\begin_layout Plain Layout


\backslash
addlist{dpstring}
\end_layout

\begin_layout Plain Layout


\backslash
addlist{palindrome}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the longest palindrome for 
\begin_inset Formula $\var s[i:j]$
\end_inset

.
 Then we have 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
1 & \text{if }i=j\\
2 & \text{else if }i+1=j\text{ and }\var s[i]=\var s[j]\\
1 & \text{else if }i+1=j\text{ and }\var s[i]\neq\var s[j]\\
2+f(i+1,j-1) & \text{else if }i+1<j\text{ and }\var s[i]=\var s[j]\\
\max(f(i+1,j)+f(i,j-1)) & \text{else if }i+1<j\text{ and }\var s[i]\neq\var s[j]
\end{cases}.
\end{equation}

\end_inset

Then the final answer is 
\begin_inset Formula $f(0,n-1),$
\end_inset

 where 
\begin_inset Formula $n=\size(s).$
\end_inset

 The overall running time is 
\begin_inset Formula $O(n^{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 517.
 Super Washing Machines
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{greedy}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Greedy
\end_layout

\begin_layout Standard
First, we need to check if the total number of machines is divisible by
 
\begin_inset Formula $n$
\end_inset

.
 If not, then it is not possible to produce the desired outcome and therefore
 return 
\begin_inset Formula $-1$
\end_inset

.
 Otherwise, we first compute the average number of clothes that are supposed
 to be in each machine, 
\begin_inset Formula $\var{avg},$
\end_inset

 keep track for each machine 
\begin_inset Formula $i$
\end_inset

, 
\begin_inset Formula 
\begin{align}
L_{i} & =\max(0,(i+1)\cdot\var{avg}+\var{RMQ}(0,i-1)),\\
R_{i} & =\max(0,(n-(i+1))\cdot\var{avg}+\var{RMQ}(i+1,n-1)),\\
T_{i} & =R_{i}+L_{i}.
\end{align}

\end_inset

Note that 
\begin_inset Formula $L_{i}$
\end_inset

 represents the total number of clothes needed to be transferred from 
\begin_inset Formula $\var{machines}[i+1:-1]$
\end_inset

 to 
\begin_inset Formula $\var{machines}[0:i-1]$
\end_inset

 if any to balance the clothes count and similarly 
\begin_inset Formula $R_{i}$
\end_inset

 represents the total number of clothes needed to be transferred from 
\begin_inset Formula $\var{machines}[0:i-1]$
\end_inset

 to 
\begin_inset Formula $\var{machines}[i+1,-1]$
\end_inset

 to balance the clothes.
 We claim that the final answer must be one of the 
\begin_inset Formula $T_{i}$
\end_inset

's.
 This is because suppose otherwise there doesn't exists a washing machines
 whose total transfer 
\begin_inset Formula $T_{i}$
\end_inset

 is not the answer, then there must be the cases where some machine 
\begin_inset Formula $A$
\end_inset

 moved once machine 
\begin_inset Formula $B$
\end_inset

 is fixed and then machine 
\begin_inset Formula $B$
\end_inset

 moved once while 
\begin_inset Formula $A$
\end_inset

 is fixed.
 This is a contradiction since 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 can be chosen at the same time.
 Hence, therefore the final answer is then 
\begin_inset Formula $\max_{i}\{T_{i}\}$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 523.
 Continuous Subarray Sum
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{prefixsum}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Prefix Sum
\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula 
\begin{align}
\left(\sum_{p=i}^{j}\var{nums}[p]\right)\mod k & =\bigg(\sum_{p=0}^{j}\var{nums}[p]-\sum_{p=i-1}^{j}\var{nums}[p]\bigg)\mod k\\
 & =\bigg[\bigg(\sum_{p=0}^{j}\var{nums}[p]\bigg)\mod k\bigg]-\bigg[\sum_{p=i-1}^{j}\var{nums}[p]\mod k\bigg].
\end{align}

\end_inset

Therefore, it follows that 
\begin_inset Formula 
\begin{equation}
\sum_{p=i}^{j}\var{nums}[p]\ |\ k\iff\bigg[\bigg(\sum_{p=0}^{j}\var{nums}[p]\bigg)\mod k\bigg]=\bigg[\sum_{p=i-1}^{j}\var{nums}[p]\mod k\bigg].
\end{equation}

\end_inset

So we need to compute the prefix sum mod of 
\begin_inset Formula $k$
\end_inset

 of 
\begin_inset Formula $\var{nums}$
\end_inset

 and use a hashmap to check.
\end_layout

\begin_layout Addsec
LeetCode 600.
 Non-negative Integers without Consecutive Ones
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpdigit}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(k)$
\end_inset

 denote the count of numbers without consecutive ones for 
\begin_inset Formula $k$
\end_inset

 digits number that starts with 
\begin_inset Formula $0$
\end_inset

.
 Then take 
\begin_inset Formula $k=6$
\end_inset

 for example, there are only two portions are valid choices, namely 
\begin_inset Formula $000000\sim011111$
\end_inset

 and 
\begin_inset Formula $010000\sim010111$
\end_inset

.
 This is because any number that starts with 
\begin_inset Formula $11...$
\end_inset

 does not meet the condition.
 Note that the count of numbers that satisfy the condition in 
\begin_inset Formula $000000\sim011111$
\end_inset

 is essentially 
\begin_inset Formula $f5)$
\end_inset

 because the first zero is fixed and similarly the count for 
\begin_inset Formula $010000\sim010111$
\end_inset

 is 
\begin_inset Formula $f(4).$
\end_inset

 Therefore, it follows that 
\begin_inset Formula 
\begin{equation}
f(k)=\begin{cases}
1 & \text{if }k=0\\
2 & \text{else if }k=1\\
f(k-2)+f(k-1) & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset

Then let 
\begin_inset Formula $g(i)$
\end_inset

 denote the count of numbers that satisfy the condition for 
\begin_inset Formula $\var{nums}[i:-1];$
\end_inset

 we have that 
\begin_inset Formula 
\begin{equation}
g(i)=\begin{cases}
1 & \text{if }i=0\text{ and }\var{binary}[i]=0\\
2 & \text{else if }i=0\text{ and }\var{binary}[i]=1\\
f(i)+g(i-1) & \text{else if }i>0\text{ and }\var{binary}[i]=1\text{ and }\var{binary}[i]=0\\
f(i)+f(i-1) & \text{else if }i>0\text{ and }\var{binary}[i]=1\text{ and }\var{binary}[i]=1\\
g(i-1) & \text{else if }i>0\text{ and }\var{binary}[i]=0
\end{cases},
\end{equation}

\end_inset

where 
\begin_inset Formula $\var{binary}$
\end_inset

is the binary representation of 
\begin_inset Formula $\var{num}.$
\end_inset

 Then final answer is then 
\begin_inset Formula $g(n-1)$
\end_inset

, where 
\begin_inset Formula $n=\size(\var{binary})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 624.
 Maximum Distance in Arrays
\end_layout

\begin_layout Paragraph
Prefix Max/Min
\end_layout

\begin_layout Standard
First, we note that if we drop the requirement that the two elements has
 to be from distinct arrays then the maximum distance has to be the 
\begin_inset Formula $\max({\tt {flatten}(\var{arrays}))-\min({\tt {flatten}(\var{arrays})).}}$
\end_inset

 On the other hand, if we require the two elements to be from distinct arrays,
 then we have to exclude the some cases.
 One thing that is invariant is that the at least one of 
\begin_inset Formula $\max({\tt {flatten}(\var{arrays}))}$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\min({\tt {flatten}(\var{arrays}))}$
\end_inset

 will be involved in the resulting optimal distance, which one could prove
 using an exchange argument.
 So let 
\begin_inset Formula $f(i)$
\end_inset

 denote the maximum distance produced with one participating element in
 
\begin_inset Formula $\var{array}[i]$
\end_inset

, then 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
\max(P_{\min}(i),P_{\max}(i),S_{\min}(i),S_{\max}(i)) & \text{if }0<i<n-1\\
\max(S_{\min}(i),S_{\max}(i)) & \text{else if }i=0\\
\max(P_{\min}(i),P_{\max}(i)) & \text{else if }i=n-1
\end{cases},
\end{equation}

\end_inset

where as
\begin_inset Formula 
\begin{align}
P_{\min}(i) & =\left|\max(\var{array}[i])-\min({\tt {flatten}(\var{array}[0:i-1]))}\right|,\\
P_{\max}(i) & =\left|\min(\var{array}[i])-\max({\tt {flatten}(\var{array}[0:i-1]))}\right|,\\
S_{\max}(i) & =\left|\max(\var{array}[i])-\min({\tt {flatten}(\var{array}[i+1:n-1]))}\right|,\\
S_{\min}(i) & =\left|\min(\var{array}[i])-\max({\tt {flatten}(\var{array}[i+1:n-1]))}\right|,
\end{align}

\end_inset

which can be computed efficiently 
\begin_inset Formula $O(n)$
\end_inset

 where 
\begin_inset Formula $n={\tt {std::size}(\var{arrays})}$
\end_inset

 using prefix min and max arrays and the sorted structure of 
\begin_inset Formula $\var{arrays}.$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18144}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 629.
 K Inverse Pairs Array
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpinterval}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 be the number of arrays from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $i$
\end_inset

 that contains 
\begin_inset Formula $j$
\end_inset

 inverse pairs.
 Then by noting that placing 
\begin_inset Formula $(i+1)$
\end_inset

 on 
\begin_inset Formula $x$
\end_inset

 positions away from the right of 
\begin_inset Formula $[1,...,i]$
\end_inset

 creates 
\begin_inset Formula $x$
\end_inset

 more inverse pairs, we have that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
1 & \text{if }i=1\text{ and }j=0\\
0 & \text{else if }i=1\text{ and }j>0\\
1 & \text{else if }j=0\\
\sum_{m=0}^{\min(i-1,j)}f(i-1,j-m) & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset

Such an algorithm has a running time complexity of 
\begin_inset Formula $O(n^{2}k)$
\end_inset

, which is unacceptable for the size of the input of the problem.
 So it is necessary to come up with an optimization scheme.
 Note that when 
\begin_inset Formula $1<i\leq j$
\end_inset

, we have that 
\begin_inset Formula 
\begin{align}
f(i,j) & =\sum_{m=0}^{\min(i-1,j)}f(i-1,j-m)=\sum_{m=0}^{i-1}f(i-1,j-m),\tag{A}\\
f(i.j-1) & =\sum_{m=0}^{\min(i-1,j-1)}f(i-1,j-1-m)=\sum_{m=1}^{i}f(i-1,j-m).\tag{B}
\end{align}

\end_inset

Subtracting (B) from (A) yields 
\begin_inset Formula 
\begin{align}
f(i,j)-f(i,j-1) & =\sum_{m=0}^{i-1}f(i-1,j-m)-\sum_{m=1}^{i}f(i-1,j-m)=f(i-1,j)-f(i-1,j-i),
\end{align}

\end_inset

which implies that 
\begin_inset Formula 
\begin{equation}
f(i,j)=f(i-1,j)+f(i,j-1)-f(i-1,j-i).
\end{equation}

\end_inset

On the other hand, if 
\begin_inset Formula $i>j>0,$
\end_inset

 we have that 
\begin_inset Formula 
\begin{align}
f(i,j) & =\sum_{m=0}^{\min(i-1,j)}f(i-1,j-m)=\sum_{m=0}^{j}f(i-1,j-m),\tag{C}\\
f(i,j-1) & =\sum_{m=0}^{\min(i-1,j-1)}f(i-1,j-1-m)=\sum_{m=1}^{j}f(i-1,j-m).\tag{D}
\end{align}

\end_inset

Subtracting (D) from (C) yields that 
\begin_inset Formula 
\begin{equation}
f(i,j)-f(i,j-1)=f(i-1,j),
\end{equation}

\end_inset

which implies that 
\begin_inset Formula 
\begin{equation}
f(i,j)=f(i-1,j)+f(i,j-1).
\end{equation}

\end_inset

Combining together, we have that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
0 & \text{if }i=1\text{ and }j>0\\
1 & \text{else if }i=1\text{ and }j=0\\
1 & \text{else if }j=1\\
f(i-1,j)+f(i,j-1) & \text{else if }i>j\\
f(i-1,j)+f(i,j-1)-f(i-1,j-i) & \text{else if }i\leq j
\end{cases}.
\end{equation}

\end_inset

Then the running time complexity is reduced to 
\begin_inset Formula $O(nk).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 639.
 Decode Ways II
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpcount}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the number of ways to decode 
\begin_inset Formula $\var s[0:i].$
\end_inset

 Then 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
9 & \text{if }i=1\text{ and }\var s[i]=\var *\\
1 & \text{else if }i=1\text{ and }s[i]\in[1,...,9]\\
1 & \text{else if }i=0\\
9\cdot f(i-1)+15\cdot f(i-2) & \text{else if }\var s[i]=\var *\text{ and }\var s[i-1]=\var *\\
9\cdot f(i-1)+9\cdot f(i-2) & \text{else if }\var s[i]=\var *\text{ and }\var s[i-1]=1\\
9\cdot f(i-1)+6\cdot f(i-2) & \text{else if }\var s[i]=\var *\text{ and }\var s[i-1]=2\\
9\cdot f(i-1) & \text{else if }\var s[i]=\var *\text{ and }\var s[i-1]\in\{0\}\cup\{3,...9\}\\
2\cdot f(i-2) & \text{else if }\var s[i]=0\text{ and }\var s[i-1]=\var *\\
f(i-2) & \text{else if }\var s[i]=0\text{ and }\var s[i-1]\in\{1,2\}\\
f(i-1)+2\cdot f(i-2) & \text{else if }\var s[i]\in\{1,...,6\}\text{ and }\var s[i-1]\in\{\var *,1,2\}\\
f(i-1) & \text{else if }\var s[i]\in\{1,...,6\}\text{ and }\var s[i-1]\in\{0\}\cup\{3,...,9\}\\
f(i-1)+f(i-2) & \text{else if }\var s[i]\in\{7,...,9\}\text{ and }\var s[i-1]\in\{\var *,1\}\\
f(i-1) & \text{else if }\var s[i]\in\{7,...,9\}\text{ and }\var s[i-1]\in\{0\}\cup\{2,...,9\}
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $f(n-1)$
\end_inset

, where 
\begin_inset Formula $n=\size(\var s).$
\end_inset

 The total running complexity is 
\begin_inset Formula $O(n).$
\end_inset

 Note that there are cases in which 
\begin_inset Formula $\var s$
\end_inset

 is not a valid input.
 We deal with these cases by exceptions.
\end_layout

\begin_layout Addsec
LeetCode 646.
 Maximum Length of Pair Chain
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dplis}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
First, we sort 
\begin_inset Formula $\var{pairs}$
\end_inset

 by lexicographical order.
 Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the maximum length of the pair chained ending with 
\begin_inset Formula $\var{pairs}[i].$
\end_inset

 Then we have
\end_layout

\begin_layout Paragraph
Patience Sorting
\end_layout

\begin_layout Addsec
LeetCode 647.
 Palindromic Substrings
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote if 
\begin_inset Formula $\var s[i:j]$
\end_inset

 is palindrome or not.
 Then we have 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
\var{true} & \text{if }i=j\\
\var{true} & \text{else if }i+1=j\text{ and }\var s[i]=\var s[j]\\
\var{false} & \text{else if }i+1=j\text{ and }\var s[i]\neq\var s[j]\\
f(i+1,j-1) & \text{else if }\var s[i]=\var s[j]\\
\var{false} & \text{else if }\var s[i]\neq\var s[j]
\end{cases}.
\end{equation}

\end_inset

Then the final answer is 
\begin_inset Formula $\sum_{(i,j)\in[0,...,n-1]^{2}}\mathbb{I}(f(i,j)=\var{true}).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 650.
 2 Keys Keyboard
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the minimum number of operations to reach 
\begin_inset Formula $i$
\end_inset

 copies of 
\begin_inset Formula $\var A$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
0 & \text{if }i=1\\
i & \text{else if }i\text{ is prime}\\
\min_{j\in[1,...,i]\text{ and }i|j}f(i/j)+j & \text{else if }i\text{ is not prime}
\end{cases},
\end{equation}

\end_inset

where 
\begin_inset Formula $f(i/j)+j$
\end_inset

 comes from 
\begin_inset Formula $f(i/j)+\underbrace{1}_{\var{copy}}+\underbrace{j-1}_{\var{paste}}.$
\end_inset

 The overall running time complexity is 
\begin_inset Formula $O(N^{2}).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 651.
 4 Keys Keyboard
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the maximum number of characters with a max of 
\begin_inset Formula $i$
\end_inset

 operations.
 Note that to achieve maximum characters the last operations must be a pressing
 
\begin_inset Formula $\var A$
\end_inset

 or pressing 
\begin_inset Formula $\var{Ctrl+V}$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
1 & \text{if }i=1\\
2 & \text{else if }i=2\\
\max(f(i-1)+1,\max_{2\leq j\leq i-2}\{f(j)\cdot(i-(j+2)+1)\} & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $f(N).$
\end_inset

 The overall running time complexity is 
\begin_inset Formula $O(N^{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 656.
 Coin Path
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the minimum path to reach 
\begin_inset Formula $n$
\end_inset

 from 
\begin_inset Formula $\var A[i].$
\end_inset

 Then 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
\var A[i] & \text{if }i=n-1\\
\min_{j\in\{i+1,...,i+B\}}\{\var A[i]+f(j)\} & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset

The final answer is then constructed by reconstructing from 
\begin_inset Formula $f$
\end_inset

.
 The running time complexity is 
\begin_inset Formula $O(nB).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 664.
 Strange Printer
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the minimum operations to print 
\begin_inset Formula $\var s[i:j]$
\end_inset

.
 Note that there are two options for the first step of 
\begin_inset Formula $\var s[i:j]:$
\end_inset

 1.
 just print one letter; 2.
 print all occurrences of 
\begin_inset Formula $\var s[i]$
\end_inset

 up to some 
\begin_inset Formula $k\in[i+1,j].$
\end_inset

 Then, it we have that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
1 & \text{if }i=j\\
0 & \text{else if }i>j\\
1 & \text{else if }i+1=j\text{ and }\var s[i]=\var s[j]\\
2 & \text{else if }i+1=j\text{ and }\var s[i]\neq\var s[j]\\
\min(1+f(i+1,j),{\displaystyle \min_{k\in[i+1,...,j]\text{ and }\var s[i]=\var s[k]}}\{f(i,k-1)+f(k+1,j)\}) & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 673.
 Number of Longest Increasing Subsequence
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the length of the longest increasing subsequence ending with 
\begin_inset Formula $\var{nums}[i],$
\end_inset

 whose precise definition can be found in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:lc300-longest-increasing-subsequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 And let 
\begin_inset Formula $g(i)$
\end_inset

 denote the number of longest increasing subsequence ending in 
\begin_inset Formula $\var{num}[i].$
\end_inset

 Then 
\begin_inset Formula 
\begin{equation}
g(i)=\begin{cases}
1 & \text{if }i=0\text{ or }\var{nums}[i]\leq\min\{\var{nums}[0:i-1]\}\\
\sum_{j=0}^{i-1}\mathbb{I}(\var{nums}[j]<\var{nums}[i])\cdot g(j) & \text{o.w. }
\end{cases}.
\end{equation}

\end_inset

The final answer is then 
\begin_inset Formula $\sum_{i=0}^{n-1}\mathbb{I}(f(i)=\var{LIS})\cdot g(i),$
\end_inset

 where 
\begin_inset Formula $n=\size(\var{nums})$
\end_inset

 and 
\begin_inset Formula $\var{LIS}=\max_{i=0}^{n-1}\{f(i)\}.$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 691.
 Stickers to Spell Word
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpmask}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(T)$
\end_inset

 denote the minimum stickers needed to fill the string 
\begin_inset Formula $T$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(T)=\begin{cases}
0 & \text{if }T=\var{\nullstring}\\
\min_{S\in\var{stickers}}(\fn{apply\_stickers}(S,T)) & \text{o.w. }
\end{cases},
\end{equation}

\end_inset

where 
\begin_inset Formula $\fn{apply\_stickers}(S,T)$
\end_inset

 applies the sticker 
\begin_inset Formula $S$
\end_inset

 to 
\begin_inset Formula $T$
\end_inset

 and returns the remaining characters to be filled.
 The final answer is 
\begin_inset Formula $f(\var{target}).$
\end_inset

 Note that 
\begin_inset Formula $T$
\end_inset

 could be represented in bitmasks.
\end_layout

\begin_layout Addsec
LeetCode 712.
 Minimum ASCII Delete Sum for Two Strings
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
First we pad 
\begin_inset Formula $\var{s1}$
\end_inset

 and 
\begin_inset Formula $\var{s2}$
\end_inset

 with 
\begin_inset Formula $\var{\#}$
\end_inset

 for the sake of Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the minimum ASCII sum to make 
\begin_inset Formula $\var{s1}[0:i]$
\end_inset

 and 
\begin_inset Formula $\var{s2}[0:j]$
\end_inset

 the same.
 Then it follows that 
\begin_inset Formula 
\begin{align}
f(i,j) & =\begin{cases}
0 & \text{if }i=0\text{ and }j=0\\
\fn{int}(\var{s1}[i])+f(i-1,j) & \text{else if }j=0\text{ and }i>0\\
\fn{int}(\var{s2}[j])+f(i,j-1) & \text{else if }i=0\text{ and }j>0\\
f(i-1,j-1) & \text{else if }\var{s1}[i]=\var{s2}[j]\\
\min(\fn{int}(\var{s1}[i])+f(i-1,j),\fn{int}(\var{s2}[j])+f(i,j-1) & \text{else if }\var{s1}[i]\neq\var{s2}[j]
\end{cases}.
\end{align}

\end_inset

The final answer is then 
\begin_inset Formula $f(n_{1}-1,n_{2}-1),$
\end_inset

 where 
\begin_inset Formula $n_{1}=\size(\var{s1})$
\end_inset

 and 
\begin_inset Formula $n_{2}=\size(\var{s2})$
\end_inset

.
 The overall running time complexity is 
\begin_inset Formula $O(n_{1}n_{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 723.
 Candy Crush
\end_layout

\begin_layout Paragraph
Simulation with Two Pointers 
\begin_inset CommandInset label
LatexCommand label
name "par:723-simulation-1"

\end_inset


\end_layout

\begin_layout Standard
Use two pointer method to mark consecutive entries in each row and each
 column.
 To do so, one can either maintain a separate matrix of boolean flags indicating
 whether the corresponding entry in 
\begin_inset Formula $\var{board}$
\end_inset

 is to be deleted or negate the value in 
\begin_inset Formula $\var{board}$
\end_inset

 directly as a flag.
 In our implementation, we choose the latter approach and the corresponding
 procedures are encapsulated in 
\begin_inset Formula ${\tt {mark\_row()}}$
\end_inset

 and 
\begin_inset Formula ${\tt {mark\_col()}}$
\end_inset

.
 The crush procedure is implemented in 
\begin_inset Formula ${\tt {crush()},}$
\end_inset

 which is routine.
 We will also implement a function 
\begin_inset Formula ${\tt {drop()}}$
\end_inset

 to simulate the gravity phenomena, which also uses a two pointer approach.
 Alternatively, one could also explicitly use a double ended queue to filter
 out the crushed candies column by column and reinsert the filtered result
 back into 
\begin_inset Formula $\var{board}$
\end_inset

 starting from the bottom of each column.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18139}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 727.
 Minimum Window Subsequence
\end_layout

\begin_layout Paragraph
Sliding Window with Greedy
\end_layout

\begin_layout Standard
Use a sliding window to accumulate result.
 Every time we come across a matching window, meaning that 
\begin_inset Formula $\var T\subseteq\var S[i:j]$
\end_inset

 for some 
\begin_inset Formula $i,j\in[0,...,n-1]$
\end_inset

, where 
\begin_inset Formula $n=\size(\var S),$
\end_inset

 we find the smallest subset 
\begin_inset Formula $\var S[k:j]$
\end_inset

 for 
\begin_inset Formula $k\in[i,...,j-1]$
\end_inset

 such that 
\begin_inset Formula $\var T\subset\var S$
\end_inset

 and update the accumulators.
\end_layout

\begin_layout Addsec
LeetCode 730.
 Count Difference Palindromic Subsequence
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpcount}
\end_layout

\begin_layout Plain Layout


\backslash
addlist{dpinterval}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the count of difference palindromic subsequences in 
\begin_inset Formula $\var S[i:j].$
\end_inset

 Then we have 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
1 & \text{if }i=j\\
2 & \text{else if }i+1=j\\
f(i+1,j)+f(i,j-1)-f(i+1,j-1) & \text{else if }\var S[i]\neq\var S[j]\\
2\cdot f(i+1,j-1)+2 & \text{else if }\var S[i]=\var S[j]\text{ and }\var S[i]\notin\var S[i+1:j-1]\\
2\cdot f(i+1,j-1)+1 & \text{else if }\var S[i]=\var S[j]\text{ and }\fn{count}(\var S[i],\var S[i+1:j-1])=1\\
2\cdot f(i+1,j-1)-f(\var{ll}+1,\var{rr}-1) & \text{else if }\var S[i]=\var S[j]\text{ and }\fn{count}(\var S[i],\var S[i+1:j-1])>1
\end{cases},
\end{equation}

\end_inset

where 
\begin_inset Formula $\var{ll}:=\min\{k\in[i+1,j-1]:\var S[k]=\var S[i]\}$
\end_inset

 and 
\begin_inset Formula $\var{ll}:=\max\{k\in[i+1,j-1]:\var S[k]=\var S[i]\}.$
\end_inset

 The final answer is 
\begin_inset Formula $f(0,n-1)$
\end_inset

, where 
\begin_inset Formula $n=\size(\var S).$
\end_inset

 The overall running time complexity is 
\begin_inset Formula $O(n^{2}).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 740.
 Delete and Earn
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
First, we let 
\begin_inset Formula $\var N$
\end_inset

 denote the sorted and no-duplicate version of 
\begin_inset Formula $\var{nums}$
\end_inset

 and 
\begin_inset Formula $\fn{score}(x)$
\end_inset

 be a function that keeps tracks of scores earned if 
\begin_inset Formula $x$
\end_inset

 is to be deleted.
 Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the number of points earned when solving the subproblem for 
\begin_inset Formula $\var N[0:i]$
\end_inset

.
 Then 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
\fn{score}(\var N[0]) & \text{if }i=0\\
\max(\fn{score}(\var N[0]),\fn{score}(\var N[1])) & \text{else if }i=1\text{ and }\var N[0]+1=\var N[1]\\
\fn{score}(\var N[0])+\fn{score}(\var N[1]) & \text{else if }i=1\text{ and }\var N[0]+1<\var N[1]\\
\max(\fn{score}(\var N[i])+f(i-2),f(i-1)) & \text{else if }i>1\text{ and }\var N[i-1]+1=\var N[i]\\
f(i-1)+\fn{score}(\var N[i]) & \text{else if }i>1\text{ and }\var N[i-1]+1<\var N[i]
\end{cases}.
\end{equation}

\end_inset

The final answer if 
\begin_inset Formula $f(n-1),$
\end_inset

 where 
\begin_inset Formula $n=\size(\var N).$
\end_inset

 The overall running time is 
\begin_inset Formula $O(n\log n).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 741.
 Cherry Pickup
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(r_{1},c_{1},r_{2})$
\end_inset

 denote the maximum cherries to be picked when for two person starting walking
 from position 
\begin_inset Formula $(r_{1},c_{1})$
\end_inset

 and 
\begin_inset Formula $(r_{2},r_{1}+c_{1}-r_{2})$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(r_{1},c_{1},r_{2})=\begin{cases}
\var{grid}[r_{1}][c_{1}] & \text{if }r_{1}=N-1\text{ and }c_{1}=N-1\text{ and }r_{2}=N-1\\
-\infty & \text{else if }\var{not}\ \fn{invalid}(r_{1},c_{2})\text{ or }\var{not}\ \fn{invalid}(r_{2},c_{2})\\
\var{grid}[r_{1}][c_{1}]+\var{grid}[r_{2}][c_{2}]+\fn{next}(r_{1},c_{1},r_{2}) & \text{else if }r_{1}+c_{1}-r_{2}\neq c_{1}\\
\var{grid}[r_{1}][c_{1}]+\fn{next}(r_{1},c_{1},r_{2}) & \text{else if }r_{1}+c_{1}-r_{2}=c_{1}
\end{cases},
\end{equation}

\end_inset

where 
\begin_inset Formula 
\begin{align}
\fn{next}(r_{1},c_{1},r_{2}) & =\max(f(r_{1}+1,c_{1},r_{1}),f(r_{1}+1,c_{1},r_{1}+1),f(r_{1},c_{1}+1,r_{1}),f(r_{1},c_{1}+1,r_{1}+1)),\\
\fn{invalid}(r,c) & =(\var{grid}[r][c]=-1)\text{ or }r=N\text{ or }c=N.
\end{align}

\end_inset

The final answer is 
\begin_inset Formula $f(0,0,0).$
\end_inset

 And the running time complexity is 
\begin_inset Formula $O(N^{3}).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 746.
 Min Cost Climbing Stairs
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the minimum cost to climb to level 
\begin_inset Formula $i$
\end_inset

.
 Then we have n
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
\min(f(i-1)+\var{cost}[i-1],f(i-2)+\var{cost}[i-2] & \text{if }i>1\\
0 & \text{else if }i\in\{0,1\}
\end{cases}.
\end{equation}

\end_inset

Then the desired answer is then 
\begin_inset Formula $f(n),$
\end_inset

 where 
\begin_inset Formula $n={\tt {std::size}(\var{cost}).}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18145}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 750.
 Number of Corner Rectangles
\end_layout

\begin_layout Paragraph
Memoization
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(r_{1},r_{2})$
\end_inset

 denote the number of corner rectangles having upper and lower sides 
\begin_inset Formula $r_{1}$
\end_inset

 and 
\begin_inset Formula $r_{2}$
\end_inset

.
 Then we have that 
\begin_inset Formula 
\begin{equation}
f(r_{1},r_{2})=\binom{\sum_{c=0}^{C-1}\mathbb{I}(\var{grid}[r_{1}][c]=1\text{ and }\var{grid}[r_{2}][c]=1)}{2}.
\end{equation}

\end_inset

The final answer is then 
\begin_inset Formula $\sum_{i=0}^{R-1}\sum_{j=i+1}^{R-1}f(i,j).$
\end_inset

 The running time complexity is 
\begin_inset Formula $O(R^{2}C).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 764.
 Largest Plus Sign
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j,k)$
\end_inset

 denote the farthest reach of consecutive ones in direction 
\begin_inset Formula $k$
\end_inset

 from 
\begin_inset Formula $\var{grid}[i][j].$
\end_inset

 Note that we need to manually construct the 
\begin_inset Formula $\var{grid}$
\end_inset

 variable since it is not given in the problem.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i,j,k)=\begin{cases}
0 & \text{if }\var{grid}[i][j]=0\\
1+\mathbb{I}(\fn{inbound}(i+\var{dr}[k],j+\var{dc}[k]))\cdot f(i+\var{dr}[k],j+\var{dc}[k],k) & \text{else if }\var{grid}[i][j]=1
\end{cases}.
\end{equation}

\end_inset

Then the length of the plus sign at 
\begin_inset Formula $\var{grid}[i][j]=\min_{k=0}^{3}\{f(i,j,k)\}.$
\end_inset

 Then it remains to accumulate the result across the 
\begin_inset Formula $\var{grid}$
\end_inset

.
 The overall running time complexity is 
\begin_inset Formula $O(N^{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 788.
 Rotated Digits
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpdigit}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 801.
 Minimum Swaps to Make Sequences Increasing
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,0)$
\end_inset

 denote the minimum swap to make both 
\begin_inset Formula $\var A[0:i]$
\end_inset

 and 
\begin_inset Formula $\var B[0:i]$
\end_inset

 sorted without swapping 
\begin_inset Formula $\var A[i]$
\end_inset

 and 
\begin_inset Formula $\var B[i]$
\end_inset

, and 
\begin_inset Formula $f(i,1)$
\end_inset

 denote the minimum swap to make both 
\begin_inset Formula $\var A[0:i]$
\end_inset

 and 
\begin_inset Formula $\var B[0:i]$
\end_inset

 sorted with swapping 
\begin_inset Formula $\var A[i]$
\end_inset

 and 
\begin_inset Formula $\var B[i]$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i,k)=\begin{cases}
\mathbb{I}(k=1) & \text{if }i=0\\
\begin{split}\min( & \mathbb{I}_{\infty}(\var A[i]>\var A[i-1]\text{ and }\var B[i]>\var B[i-1])\cdot f(i-1,0),\\
 & \mathbb{I}_{\infty}(\var A[i]>\var B[i-1]\text{ and }\var B[i]>\var A[i-1])\cdot f(i-1,1))
\end{split}
 & \text{else if }i>0\text{ and }k=0\\
\begin{split}\min( & \mathbb{I}_{\infty}(\var A[i]>\var A[i-1]\text{ and }\var B[i]>\var B[i-1])\cdot f(i-1,1)+1,\\
 & \mathbb{I}_{\infty}(\var A[i]>\var B[i-1]\text{ and }\var B[i]>\var A[i-1])\cdot f(i-1,0)+1)
\end{split}
 & \text{else if }i>0\text{ and }k=1
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $\min(f(n-1,0),f(n-1,1)),$
\end_inset

 where 
\begin_inset Formula $n=\size(\var A).$
\end_inset

The running time complexity is 
\begin_inset Formula $O(n).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 808.
 Soup Servings
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(a,b)$
\end_inset

 denote the probability of exhausting 
\begin_inset Formula $A$
\end_inset

 first plus half the probability of exhausting both 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 at the same time with 
\begin_inset Formula $a$
\end_inset

 units of soup 
\begin_inset Formula $A$
\end_inset

 remaining and 
\begin_inset Formula $b$
\end_inset

 units of the soup 
\begin_inset Formula $B$
\end_inset

 remaining.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(a,b)=\begin{cases}
0 & \text{if }a\leq0\text{ and }b\leq0\\
1 & \text{else if }a\leq0\text{ and }b>0\\
0 & \text{else if }a>0\text{ and }b\leq0\\
\frac{1}{4}(f(a-100,b)+f(a-75,b-25)+f(a-50,b-50)+f(a-75,b-25)) & \text{o.w. }
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $O(N).$
\end_inset

 We also note that as 
\begin_inset Formula $N\rightarrow\infty$
\end_inset

, 
\begin_inset Formula $f(N,N)\rightarrow1.$
\end_inset

 To see this, let 
\begin_inset Formula $Y$
\end_inset

 denote the surplus number of units distributed 
\begin_inset Formula $A$
\end_inset

 compared to 
\begin_inset Formula $B$
\end_inset

.
 Then we have that 
\begin_inset Formula 
\begin{align}
\mathbb{E}[Y] & =\frac{1}{4}(100+50+0-50)=25;\\
\mathrm{Var}[Y] & =\frac{1}{4}(100^{2}+50^{2}+0+50^{2})-25^{2}=3125.
\end{align}

\end_inset

Let 
\begin_inset Formula $S_{n}$
\end_inset

 denote the total surplus distributing 
\begin_inset Formula $n$
\end_inset

 rounds of soups.
 Then 
\begin_inset Formula $S_{n}\sim\mathrm{N}(25n,\sqrt{3125n})\simeq\mathrm{N}(25n,60\sqrt{n}).$
\end_inset

 Then by calculation we see that when 
\begin_inset Formula $n\geq200,$
\end_inset

 
\begin_inset Formula $\mathbb{P}(S_{n}<0)$
\end_inset

 is very close to 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 813.
 Largest Sum of Averages
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,k)$
\end_inset

 denote the maximum 
\begin_inset Formula $k$
\end_inset

-group average sum for 
\begin_inset Formula $\var A[0:i]$
\end_inset

.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i,k)=\begin{cases}
\fn{RSQ}(0,i) & \text{if }i+1=k\\
\fn{RSQ}(0,i)/(i+1) & \text{else if }k=1\\
{\displaystyle \max_{j=k-1}^{i}(f(j-1,k-1)+\fn{RSQ}(j,i)/(i-j+1))} & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset

The final answer is 
\begin_inset Formula $f(n-1,k).$
\end_inset

 The overall running time complexity is 
\begin_inset Formula $O(n^{2})$
\end_inset

.
\end_layout

\begin_layout Addsec
LeetCode 837.
 New 21 Game
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)=\mathbb{P}(\mathrm{win}\vert x_{t}=i).$
\end_inset

 Then we have 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
1 & \text{if }K\leq i\leq\min(N,K+W)\\
0 & \text{else if }i>N\\
\sum_{k=1}^{W}\mathbb{P}(\mathrm{win}\vert x_{t+1}=i+k)\mathbb{P}(x_{t+1}=i+k\vert x_{t}=i)=\sum_{k=1}^{W}\frac{1}{W}f(i+k) & \text{o.w. }
\end{cases}.
\end{equation}

\end_inset

The final answer is then 
\begin_inset Formula $f(0).$
\end_inset

 Note that complexity of the evaluation of 
\begin_inset Formula $f(0)$
\end_inset

 is 
\begin_inset Formula $O(NK)$
\end_inset

 which is too high to pass the OJ.
 We thus seek optimizations.
 Note that for 
\begin_inset Formula $i\leq K-2,$
\end_inset

 we have 
\begin_inset Formula 
\begin{align}
f(i) & =\sum_{k=1}^{W}\frac{1}{W}f(i+k),\\
f(i+1) & =\sum_{k=1}^{W}\frac{1}{W}f(i+1+k),
\end{align}

\end_inset

from which we have 
\begin_inset Formula 
\begin{equation}
f(i)-f(i+1)=\frac{1}{W}(f(i+1)-f(i+1+k)),
\end{equation}

\end_inset

whence we have 
\begin_inset Formula 
\begin{equation}
f(i)=f(i+1)+\frac{1}{W}(f(i+1)-f(i+1+k))\text{ for }i\leq K-2.
\end{equation}

\end_inset

Note that when 
\begin_inset Formula $i=K-1,$
\end_inset

 we have 
\begin_inset Formula 
\begin{equation}
f(i)=\frac{1}{W}\left(\min(N,K-1+W)-K+1\right).
\end{equation}

\end_inset

Therefore, it follows that we can rewrite 
\begin_inset Formula $f$
\end_inset

 in the following way: 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
1 & \text{if }K\leq i\leq\min(N,K+W)\\
0 & \text{else if }i>\min(N,K+W)\\
\frac{1}{W}(\min(N,K-1+W)-K+1) & \text{else if }i=K-1\\
f(i+1)+
\end{cases}
\end{equation}

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 877.
 Stone Game
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpminimax}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i,j)$
\end_inset

 denote the difference between the numbers of stones between Alex and Lee
 if they are to pick from 
\begin_inset Formula $\var{piles}[i:j]$
\end_inset

 with Alex picks first.
 Then note that because each player is playing optimally, 
\begin_inset Formula $f(i,j)$
\end_inset

 is also equal to the difference when Lee picks first.
 Then it follows that 
\begin_inset Formula 
\begin{equation}
f(i,j)=\begin{cases}
\max(\var{piles}[i],\var{piles}[j])-\min(\var{pile}[i],\var{piles}[j]) & \text{if }i+1=j\\
\max(\var{piles}[i]-f(i+1,j),\var{piles}[j]-f(i,j-1)) & \text{o.w.}
\end{cases}.
\end{equation}

\end_inset

Then the final answer is 
\begin_inset Formula $f(0,n-1)>0,$
\end_inset

 where 
\begin_inset Formula $n=\size(\var{piles}).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 902.
 Number At Most 
\begin_inset Formula $N$
\end_inset

 Given Digit Set
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpdigit}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 983.
 Minimum Cost For Tickets
\end_layout

\begin_layout Paragraph
Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $f(i)$
\end_inset

 denote the minimum costs to cover 
\begin_inset Formula $\var{days}[0:i]$
\end_inset

.
 Then we have 
\begin_inset Formula 
\begin{equation}
f(i)=\begin{cases}
\max(\var{costs}[0],\var{costs}[1],\var{costs}[2]) & \If i=0\\
\max(\var{costs}[i]+f(\fn{next\_lower}(\var{days}[0:i-1],\var{days}[i]-\var{pass}[i])) & \text{else if }i\neq\emptyset,i>0\\
0 & \text{else if }i=\emptyset
\end{cases},
\end{equation}

\end_inset

where 
\begin_inset Formula $\fn{next\_lower}(A,x)$
\end_inset

 return last element in array 
\begin_inset Formula $A$
\end_inset

 that is strictly less than 
\begin_inset Formula $x$
\end_inset

; we note that this procedure can be implemented in 
\begin_inset Formula $O(\log n)$
\end_inset

 times using binary search.
 Thus, the overall time complexity is 
\begin_inset Formula $O(n\log n)$
\end_inset

, where 
\begin_inset Formula $n=\fn{std::size}(\var{days}).$
\end_inset


\end_layout

\begin_layout Addsec
LeetCode 1012.
 Numbers With Repeated Digits
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpdigit}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 1346.
 Check if N and Its Double Exist
\end_layout

\begin_layout Paragraph
HashSet
\end_layout

\begin_layout Standard
Create a hashset 
\begin_inset Formula $\var{arr\_set}$
\end_inset

 to store non-zero unique elements in 
\begin_inset Formula $\var{arr}$
\end_inset

.
 Then we count the number of zeros in 
\begin_inset Formula $\var{arr},$
\end_inset

 if there are at least two zeros, we return 
\begin_inset Formula $\var{true}$
\end_inset

 immediately; otherwise we loop through 
\begin_inset Formula $\var{arr\_set}$
\end_inset

 check if the condition is met.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18146}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 1351.
 Count Negative Numbers in a Sorted Matrix
\end_layout

\begin_layout Paragraph
Binary Search
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $[R,C]={\tt {dimension}(\var{grid})}$
\end_inset

.
 We count row by row.
 If 
\begin_inset Formula $\var{grid}[r][0]<0$
\end_inset

 for some 
\begin_inset Formula $r\in[0,R-1]$
\end_inset

, then we add all the items in the submatrix 
\begin_inset Formula $\var{grid}[r:R-1][0:C-1]$
\end_inset

 to the final result; otherwise, we will use binary search to find the first
 negative entry 
\begin_inset Formula $c_{N}$
\end_inset

 in each row and add to the final result 
\begin_inset Formula $C-c_{N}.$
\end_inset

 The count process could be implemented as a function 
\begin_inset Formula $f(r)$
\end_inset

, where 
\begin_inset Formula $f(i)$
\end_inset

 means the number of negative entries when counting from row 
\begin_inset Formula $i$
\end_inset

.
 Then 
\begin_inset Formula 
\begin{equation}
f(r)=\begin{cases}
C-c_{N}+f(r+1) & \text{if }\min(\var{grid}[r])<0\\
0 & \text{else if }\min(\var{grid}[r])>0\text{ or }r=R\\
(R-r)\cdot C & \text{else if }\text{\var{grid}}[r][0]<0
\end{cases}.
\end{equation}

\end_inset

And the desired answer is 
\begin_inset Formula $f(0).$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18156}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 1365.
 How Many Numbers Are Smaller Than the Current Number
\end_layout

\begin_layout Paragraph
Bucket Sort with Prefix Sum
\end_layout

\begin_layout Standard
Create a bucket array, 
\begin_inset Formula $\var{bucket}$
\end_inset

, to store all the values in 
\begin_inset Formula $\var{nums}$
\end_inset

 and then create range query module of 
\begin_inset Formula $\var{bucket}$
\end_inset

 using prefix sum, which we name as 
\begin_inset Formula ${\tt {RSQ}.}$
\end_inset

 Let 
\begin_inset Formula $A$
\end_inset

 denote the desired array, then we have 
\begin_inset Formula 
\begin{equation}
A[i]=\begin{cases}
0 & \text{if }\var{nums}[i]=0\\
{\tt {RSQ}(0,\var{nums}[i]-1)} & \text{otherwise}
\end{cases}.
\end{equation}

\end_inset

The overall runtime complexity is 
\begin_inset Formula $O(n)$
\end_inset

 and memory complexity is 
\begin_inset Formula $O(n).$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18157}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 1380.
 Lucky Numbers in a Matrix
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Create two arrays, 
\begin_inset Formula $\var{row\_min}$
\end_inset

 and 
\begin_inset Formula $\var{col\_max}$
\end_inset

, to store the minimum (maximum) of each row (column).
 Then we iterate through every entries 
\begin_inset Formula $\var{matrix}$
\end_inset

 to check for lucky numbers.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18163}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 1385.
 Find the Distance Value Between Two Arrays
\end_layout

\begin_layout Paragraph
Binary Search
\end_layout

\begin_layout Standard
We first let 
\begin_inset Formula $\var{sorted\_arr2}$
\end_inset

 be a sorted copy of 
\begin_inset Formula $\var{arr2}.$
\end_inset

 Then for each 
\begin_inset Formula $i\in[0,n_{1}-1]$
\end_inset

, where 
\begin_inset Formula $n_{2}={\tt {std::size}(\var{arr1}),}$
\end_inset

 we use binary search to locate 
\begin_inset Formula $l,r$
\end_inset

 such that 
\begin_inset Formula $\var{sorted\_arr2}[l:r]\subseteq[\var{arr1}[i]-d,\var{arr1}[i]+d]$
\end_inset

 and add the element count of 
\begin_inset Formula $\var{sorted\_arr2}[l:r]$
\end_inset

 to the final result.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18169}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 1389.
 Create Target Array in the Given Order
\end_layout

\begin_layout Paragraph
Simulation
\end_layout

\begin_layout Standard
Just simply create a 
\begin_inset Formula ${\tt {std::vector<int>}}$
\end_inset

 and simulate the process using 
\begin_inset Formula ${\tt {insert}}$
\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18170}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 1394.
 Find Lucky Integer in an Array
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Create a hashmap 
\begin_inset Formula $\var{freq\_map}$
\end_inset

 to count the occurrences of each number in 
\begin_inset Formula $\var{arr}$
\end_inset

.
 Then filter out the keys in 
\begin_inset Formula $\var{freq\_map}$
\end_inset

 that satisfies the condition into a list, and return the maximum the list
 if the list is non-empty or -1 if otherwise.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
acwinglink{18213}
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
LeetCode 1397.
 Find All Good Strings
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addlist{dpdigit}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
